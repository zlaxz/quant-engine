{
  "id": "fix-react-memo-backtest",
  "domain": "repair-react",
  "status": "success",
  "result": "Now I'll analyze the code for performance issues. I can see several areas that need optimization:\n\n1. The component is not memoized with `React.memo`\n2. The `toggleRegime` function is not wrapped in `useCallback`\n3. There are 6 `useState` calls, which suggests a `useReducer` refactor could be beneficial\n\nLet me provide the exact code changes:\n\n## Performance Fixes for BacktestRunner.tsx\n\n### 1. Wrap component export in React.memo\n\n**Lines 1-3 (at the end of file):**\n```typescript\nexport function BacktestRunner() {\n```\n\n**Change to:**\n```typescript\nfunction BacktestRunner() {\n```\n\n**Add at the end of file (after the component function):**\n```typescript\nexport default React.memo(BacktestRunner);\n```\n\n### 2. Add useCallback to toggleRegime function\n\n**Lines 134-142:**\n```typescript\n  const toggleRegime = (regime: string) => {\n    setConfig((prev) => ({\n      ...prev,\n      regimeFilter: prev.regimeFilter.includes(regime)\n        ? prev.regimeFilter.filter((r) => r !== regime)\n        : [...prev.regimeFilter, regime],\n    }));\n  };\n```\n\n**Change to:**\n```typescript\n  const toggleRegime = useCallback((regime: string) => {\n    setConfig((prev) => ({\n      ...prev,\n      regimeFilter: prev.regimeFilter.includes(regime)\n        ? prev.regimeFilter.filter((r) => r !== regime)\n        : [...prev.regimeFilter, regime],\n    }));\n  }, []);\n```\n\n### 3. Add useCallback to other config update functions\n\n**Lines 148-152 (Select onValueChange):**\n```typescript\n                onValueChange={(v) => setConfig((prev) => ({ ...prev, strategyId: v }))}\n```\n\n**Change to:**\n```typescript\n                onValueChange={useCallback((v: string) => \n                  setConfig((prev) => ({ ...prev, strategyId: v })), [])}\n```\n\n**Lines 164-168 (startDate onChange):**\n```typescript\n                  onChange={(e) =>\n                    setConfig((prev) => ({ ...prev, startDate: e.target.value }))\n                  }\n```\n\n**Change to:**\n```typescript\n                  onChange={useCallback((e: React.ChangeEvent<HTMLInputElement>) =>\n                    setConfig((prev) => ({ ...prev, startDate: e.target.value })), [])}\n```\n\n**Lines 175-179 (endDate onChange):**\n```typescript\n                  onChange={(e) =>\n                    setConfig((prev) => ({ ...prev, endDate: e.target.value }))\n                  }\n```\n\n**Change to:**\n```typescript\n                  onChange={useCallback((e: React.ChangeEvent<HTMLInputElement>) =>\n                    setConfig((prev) => ({ ...prev, endDate: e.target.value })), [])}\n```\n\n**Lines 186-194 (initialCapital onChange):**\n```typescript\n                onChange={(e) =>\n                  setConfig((prev) => ({\n                    ...prev,\n                    initialCapital: parseInt(e.target.value) || 0,\n                  }))\n                }\n```\n\n**Change to:**\n```typescript\n                onChange={useCallback((e: React.ChangeEvent<HTMLInputElement>) =>\n                  setConfig((prev) => ({\n                    ...prev,\n                    initialCapital: parseInt(e.target.value) || 0,\n                  })), [])}\n```\n\n**Lines 207-211 (slippageModel onValueChange):**\n```typescript\n                onValueChange={(v: 'zero' | 'realistic' | 'conservative') =>\n                  setConfig((prev) => ({ ...prev, slippageModel: v }))\n                }\n```\n\n**Change to:**\n```typescript\n                onValueChange={useCallback((v: 'zero' | 'realistic' | 'conservative') =>\n                  setConfig((prev) => ({ ...prev, slippageModel: v })), [])}\n```\n\n### 4. Suggestion for useReducer refactor (optional but recommended)\n\nSince there are 6 useState calls, here's a suggestion for a useReducer refactor:\n\n**Add this type definition near the top (after imports):**\n```typescript\ntype BacktestState = {\n  strategies: Strategy[];\n  config: BacktestConfig;\n  running: boolean;\n  progress: number;\n  progressMessage: string;\n  result: BacktestResult | null;\n  recentResults: BacktestResult[];\n};\n\ntype BacktestAction =\n  | { type: 'SET_STRATEGIES'; payload: Strategy[] }\n  | { type: 'UPDATE_CONFIG'; payload: Partial<BacktestConfig> }\n  | { type: 'SET_RUNNING'; payload: boolean }\n  | { type: 'SET_PROGRESS'; payload: { progress: number; message: string } }\n  | { type: 'SET_RESULT'; payload: BacktestResult | null }\n  | { type: 'ADD_RECENT_RESULT'; payload: BacktestResult };\n```\n\n**Replace the 6 useState calls (lines 77-84) with:**\n```typescript\n  const [state, dispatch] = useReducer(\n    (prevState: BacktestState, action: BacktestAction): BacktestState => {\n      switch (action.type) {\n        case 'SET_STRATEGIES':\n          return { ...prevState, strategies: action.payload };\n        case 'UPDATE_CONFIG':\n          return { ...prevState, config: { ...prevState.config, ...action.payload } };\n        case 'SET_RUNNING':\n          return { ...prevState, running: action.payload };\n        case 'SET_PROGRESS':\n          return { \n            ...prevState, \n            progress: action.payload.progress,\n            progressMessage: action.payload.message \n          };\n        case 'SET_RESULT':\n          return { ...prevState, result: action.payload };\n        case 'ADD_RECENT_RESULT':\n          return { \n            ...prevState, \n            recentResults: [action.payload, ...prevState.recentResults].slice(0, 5) \n          };\n        default:\n          return prevState;\n      }\n    },\n    {\n      strategies: [],\n      config: {\n        strategyId: '',\n        startDate: '2023-01-01',\n        endDate: format(new Date(), 'yyyy-MM-dd'),\n        initialCapital: 100000,\n        regimeFilter: [],\n        slippageModel: 'realistic',\n      },\n      running: false,\n      progress: 0,\n      progressMessage: '',\n      result: null,\n      recentResults: [],\n    }\n  );\n\n  // Destructure for easier access\n  const { strategies, config, running, progress, progressMessage, result, recentResults } = state;\n```\n\n**Update all state setters to use dispatch:**\n\n- `setStrategies(data || [])` \u2192 `dispatch({ type: 'SET_STRATEGIES', payload: data || [] })`\n- `setConfig(...)` \u2192 `dispatch({ type: 'UPDATE_CONFIG', payload: {...} })`\n- `setRunning(true)` \u2192 `dispatch({ type: 'SET_RUNNING', payload: true })`\n- `setProgress(step.progress)` and `setProgressMessage(step.message)` \u2192 `dispatch({ type: 'SET_PROGRESS', payload: { progress: step.progress, message: step.message } })`\n- `setResult(mockResult)` \u2192 `dispatch({ type: 'SET_RESULT', payload: mockResult })`\n- `setRecentResults((prev) => [mockResult, ...prev].slice(0, 5))` \u2192 `dispatch({ type: 'ADD_RECENT_RESULT', payload: mockResult })`\n\n**Update toggleRegime to use dispatch:**\n```typescript\n  const toggleRegime = useCallback((regime: string) => {\n    dispatch({\n      type: 'UPDATE_CONFIG',\n      payload: {\n        regimeFilter: config.regimeFilter.includes(regime)\n          ? config.regimeFilter.filter((r) => r !== regime)\n          : [...config.regimeFilter, regime],\n      },\n    });\n  }, [config.regimeFilter]);\n```\n\n## Summary of Changes:\n\n1. **React.memo**: Wrapped component export to prevent unnecessary re-renders\n2. **useCallback**: Applied to all event handlers including `toggleRegime` and config update functions\n3. **useReducer**: Suggested refactor for the 6 useState calls to manage complex state more efficiently\n\nThe most critical fixes are #1 and #2. The useReducer refactor (#3) is optional but highly recommended for better performance and maintainability with this many state variables."
}