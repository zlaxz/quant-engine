{
  "id": "cq-02-react-patterns",
  "domain": "code-quality",
  "status": "success",
  "result": "Based on my analysis of the codebase, here's my comprehensive review of React component patterns in `/src/components/`:\n\n## React Component Patterns Review\n\n### 1. **Unnecessary Re-renders (Missing memo, useMemo, useCallback)**\n\n**Issues Found:**\n\n#### **A. Missing `React.memo` for expensive components**\n- **BacktestRunner.tsx** (Lines 1-400): Large component with complex state and multiple child components. No memoization.\n- **QuantPanel.tsx** (Lines 1-400): Complex component with multiple effects and state updates. No memoization.\n- **ActivityFeed.tsx** (Lines 1-200): Real-time component that updates frequently. No memoization.\n\n#### **B. Inconsistent use of `useCallback`**\n- **Good**: Some components properly use `useCallback` for event handlers (CommandPalette.tsx, ChatArea.tsx)\n- **Bad**: Many components define inline functions that recreate on every render:\n  - **BacktestRunner.tsx** (Lines 197-200): `stopBacktest` uses `useCallback` but `toggleRegime` (line 197) doesn't\n  - **QuantPanel.tsx**: Multiple inline functions in JSX (event handlers) without `useCallback`\n\n#### **C. Missing `useMemo` for expensive computations**\n- **MessageCard.tsx** (Line 386): **Good** - uses `useMemo` for `parseRichContent`\n- **FindingsPanel.tsx** (Lines 36, 48): **Good** - uses `useMemo` for sorting/filtering\n- **But**: Many components compute derived state inline without memoization\n\n### 2. **State Management Anti-patterns**\n\n#### **A. Multiple related state variables that should be combined**\n- **BacktestRunner.tsx** (Lines 87-100):\n  ```typescript\n  const [strategies, setStrategies] = useState<Strategy[]>([]);\n  const [config, setConfig] = useState<BacktestConfig>({...});\n  const [running, setRunning] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<BacktestResult | null>(null);\n  const [recentResults, setRecentResults] = useState<BacktestResult[]>([]);\n  ```\n  **Issue**: These are all related to backtest state and should be combined into a single state object or useReducer.\n\n#### **B. Derived state computed inline instead of using `useMemo`**\n- **ActivityFeed.tsx** (Lines 189-220): Events are filtered/sorted inline in render\n- **QuantPanel.tsx**: Multiple inline computations in render\n\n#### **C. State initialization with function calls**\n- **FindingsPanel.tsx** (Line 32):\n  ```typescript\n  const [findings, setFindings] = useState<Finding[]>(loadFindings());\n  ```\n  **Issue**: `loadFindings()` runs on every render. Should be:\n  ```typescript\n  const [findings, setFindings] = useState<Finding[]>(() => loadFindings());\n  ```\n\n### 3. **Effect Dependencies Issues**\n\n#### **A. Missing dependencies in `useEffect`**\n- **RightPanel.tsx** (Line 22):\n  ```typescript\n  useEffect(() => {\n    if (typeof window !== 'undefined' && window.electron?.onClaudeCodeEvent) {\n      // ...\n    }\n    return undefined;\n  }, []);\n  ```\n  **Issue**: Empty dependency array but uses `window.electron` which could change\n\n#### **B. Unnecessary dependencies**\n- **ContextPanel.tsx** (Line 72):\n  ```typescript\n  useEffect(() => {\n    if (selectedWorkspaceId) {\n      loadContextData();\n    }\n  }, [selectedWorkspaceId, loadContextData]);\n  ```\n  **Issue**: `loadContextData` is already memoized with `useCallback`, but it's included as dependency\n\n#### **C. Infinite loop risk**\n- **ActivityFeed.tsx** (Lines 213-220):\n  ```typescript\n  useEffect(() => {\n    if (isLive && scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n    }\n  }, [events, isLive]);\n  ```\n  **Issue**: This runs on every `events` change, which could cause performance issues\n\n### 4. **Component Composition Problems**\n\n#### **A. Prop drilling**\n- **QuantPanel.tsx** (Line 1): Receives `selectedRunIdFromMemory` prop but doesn't pass it down effectively\n- Complex prop chains through multiple components\n\n#### **B. Large monolithic components**\n- **BacktestRunner.tsx**: 400+ lines, handles UI, state, API calls, and business logic\n- **QuantPanel.tsx**: 400+ lines, similar issues\n\n#### **C. Missing error boundaries for specific components**\n- **ErrorBoundary.tsx** exists but not widely used. Components like:\n  - **BacktestRunner.tsx** (network calls)\n  - **QuantPanel.tsx** (complex computations)\n  - **ActivityFeed.tsx** (real-time streams)\n  Should be wrapped in error boundaries\n\n### 5. **Error Boundary Coverage**\n\n#### **A. Only one global ErrorBoundary**\n- **ErrorBoundary.tsx** is well-implemented but likely used only at app root\n- No component-specific error boundaries for critical sections\n\n#### **B. Missing error handling in async operations**\n- **BacktestRunner.tsx** (Lines 127-197): `runBacktest` has try-catch but errors are swallowed\n- **QuantPanel.tsx** (Lines 85-135): `runBacktest` has error handling but not comprehensive\n\n## **Specific Issues with Code References:**\n\n### **Critical Issues:**\n\n1. **BacktestRunner.tsx (Line 197):**\n   ```typescript\n   const toggleRegime = (regime: string) => {\n     setConfig((prev) => ({\n       ...prev,\n       regimeFilter: prev.regimeFilter.includes(regime)\n         ? prev.regimeFilter.filter((r) => r !== regime)\n         : [...prev.regimeFilter, regime],\n     }));\n   };\n   ```\n   **Fix**: Wrap in `useCallback` with `[config.regimeFilter]` dependency\n\n2. **QuantPanel.tsx (Lines 47-52):**\n   ```typescript\n   useEffect(() => {\n     loadStrategies();\n   }, []);\n\n   useEffect(() => {\n     if (selectedRunIdFromMemory) {\n       loadRunById(selectedRunIdFromMemory);\n     }\n   }, [selectedRunIdFromMemory]);\n   ```\n   **Issue**: `loadStrategies` and `loadRunById` should be memoized with `useCallback`\n\n3. **ActivityFeed.tsx (Line 195):**\n   ```typescript\n   useEffect(() => {\n     if (!window.electron?.onDaemonLog) return;\n     // ...\n   }, []);\n   ```\n   **Issue**: Missing cleanup function for event listener\n\n### **Performance Issues:**\n\n1. **MessageCard.tsx**: Well-optimized with `memo` and `useMemo`\n2. **But**: Parent components (ChatArea.tsx) don't memoize message lists\n\n3. **RightPanel.tsx (Line 22):**\n   ```typescript\n   useEffect(() => {\n     if (typeof window !== 'undefined' && window.electron?.onClaudeCodeEvent) {\n       const cleanup = window.electron.onClaudeCodeEvent((event) => {\n         // ...\n         setClaudeCodeCommands(prev => [command, ...prev].slice(0, 20));\n       });\n       return cleanup;\n     }\n     return undefined;\n   }, []);\n   ```\n   **Issue**: Event handler runs on every event, causing frequent re-renders\n\n## **Recommended Fixes:**\n\n### **Immediate Fixes (High Priority):**\n\n1. **Wrap expensive components in `React.memo`:**\n   ```typescript\n   export const BacktestRunner = React.memo(function BacktestRunner() { ... });\n   ```\n\n2. **Add `useCallback` to event handlers:**\n   ```typescript\n   const toggleRegime = useCallback((regime: string) => {\n     // ...\n   }, [config.regimeFilter]);\n   ```\n\n3. **Fix useEffect dependencies:**\n   ```typescript\n   // RightPanel.tsx\n   useEffect(() => {\n     const handler = (event) => { ... };\n     if (window.electron?.onClaudeCodeEvent) {\n       const cleanup = window.electron.onClaudeCodeEvent(handler);\n       return cleanup;\n     }\n   }, []); // Keep empty if handler doesn't depend on state\n   ```\n\n### **Medium Priority Fixes:**\n\n1. **Combine related state with `useReducer`:**\n   ```typescript\n   // BacktestRunner.tsx\n   const [state, dispatch] = useReducer(backtestReducer, initialState);\n   ```\n\n2. **Add component-specific error boundaries:**\n   ```typescript\n   <ErrorBoundary>\n     <BacktestRunner />\n   </ErrorBoundary>\n   ```\n\n3. **Use `useMemo` for derived state:**\n   ```typescript\n   const filteredEvents = useMemo(() => \n     events.filter(e => e.type !== 'info'), \n   [events]);\n   ```\n\n### **Architectural Improvements:**\n\n1. **Extract custom hooks:**\n   ```typescript\n   // useBacktest.ts\n   export function useBacktest() {\n     const [state, setState] = useState(initialState);\n     const runBacktest = useCallback(async () => { ... }, []);\n     return { state, runBacktest };\n   }\n   ```\n\n2. **Split large components:**\n   - Extract `BacktestConfigForm` from `BacktestRunner`\n   - Extract `BacktestResultsDisplay` from `BacktestRunner`\n\n3. **Implement proper cleanup in effects:**\n   ```typescript\n   useEffect(() => {\n     let mounted = true;\n     const fetchData = async () => {\n       if (mounted) { ... }\n     };\n     fetchData();\n     return () => { mounted = false; };\n   }, []);\n   ```\n\n## **Summary:**\n\nThe codebase shows **good patterns** in some areas (MessageCard.tsx uses memoization well) but has **significant performance issues** in others. The main problems are:\n\n1. **Missing memoization** for expensive components\n2. **Inline function creation** causing unnecessary re-renders\n3. **Large monolithic components** that should be split\n4. **Incomplete error handling** and error boundary coverage\n5. **Effect dependency issues** that could cause bugs\n\n**Most critical**: `BacktestRunner.tsx`, `QuantPanel.tsx`, and `ActivityFeed.tsx` need immediate optimization with `React.memo` and proper `useCallback` usage."
}