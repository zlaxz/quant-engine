/**
 * Documentation Operations - Auto-generate docstrings, READMEs, and code templates
 * Phase 7: Documentation & Code Generation
 */

interface DocstringResult {
  success: boolean;
  modified_functions?: string[];
  summary?: string;
  error?: string;
  preview?: string;
}

interface ReadmeResult {
  success: boolean;
  readme_path?: string;
  content?: string;
  error?: string;
}

interface StrategyTemplateResult {
  success: boolean;
  file_path?: string;
  content?: string;
  error?: string;
}

interface ProfileTemplateResult {
  success: boolean;
  file_path?: string;
  content?: string;
  error?: string;
}

/**
 * Generate docstrings for undocumented functions in a Python file
 * Uses LLM to generate numpy/google style docstrings
 */
export async function generateDocstrings(
  filePath: string,
  engineRoot: string,
  llmApiKey: string
): Promise<DocstringResult> {
  try {
    // FIXED: Validate LLM API key before proceeding
    if (!llmApiKey || llmApiKey.trim() === '') {
      return {
        success: false,
        error: 'LOVABLE_API_KEY is required for documentation generation. Please configure it in Supabase secrets.'
      };
    }

    // Read the file
    const fullPath = `${engineRoot}/${filePath}`;
    const content = await Deno.readTextFile(fullPath);
    
    // Use LLM to generate docstrings
    const prompt = `You are a Python documentation expert. Analyze the following Python code and generate numpy-style docstrings for all functions that lack documentation.

For each function without a docstring:
1. Describe what the function does clearly and concisely
2. Document all parameters with types and descriptions
3. Document return values with types
4. Use numpy docstring format

Return the COMPLETE modified file with docstrings added. Do not truncate or summarize.

Code to document:
\`\`\`python
${content}
\`\`\`

Return only the modified Python code, no explanations.`;

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${llmApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: 'You are a Python documentation expert. Generate complete, accurate numpy-style docstrings.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.3,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: `LLM API error: ${response.status} ${errorText}`
      };
    }

    const data = await response.json();
    const generatedContent = data.choices?.[0]?.message?.content;
    
    if (!generatedContent) {
      return {
        success: false,
        error: 'No content generated by LLM'
      };
    }

    // Extract code from markdown code blocks if present
    let modifiedContent = generatedContent;
    const codeBlockMatch = generatedContent.match(/```python\n([\s\S]*?)\n```/);
    if (codeBlockMatch) {
      modifiedContent = codeBlockMatch[1];
    }

    // Count modified functions (heuristic: count new docstrings added)
    const originalDocstringCount = (content.match(/"""[\s\S]*?"""/g) || []).length;
    const modifiedDocstringCount = (modifiedContent.match(/"""[\s\S]*?"""/g) || []).length;
    const addedDocstrings = Math.max(0, modifiedDocstringCount - originalDocstringCount);

    return {
      success: true,
      modified_functions: [`${addedDocstrings} docstrings added`],
      summary: `Generated docstrings for ${filePath}. Added ${addedDocstrings} new docstrings.`,
      preview: modifiedContent.slice(0, 1000) + (modifiedContent.length > 1000 ? '\n...(truncated)' : '')
    };

  } catch (error: any) {
    return {
      success: false,
      error: `Failed to generate docstrings: ${error.message}`
    };
  }
}

/**
 * Generate README for a module or package
 */
export async function generateReadme(
  modulePath: string,
  engineRoot: string,
  llmApiKey: string
): Promise<ReadmeResult> {
  try {
    // FIXED: Validate LLM API key before proceeding
    if (!llmApiKey || llmApiKey.trim() === '') {
      return {
        success: false,
        error: 'LOVABLE_API_KEY is required for README generation. Please configure it in Supabase secrets.'
      };
    }

    const fullPath = `${engineRoot}/${modulePath}`;
    
    // Check if path is directory or file
    let stat;
    try {
      stat = await Deno.stat(fullPath);
    } catch {
      return {
        success: false,
        error: `Path not found: ${modulePath}`
      };
    }

    let filesToAnalyze: string[] = [];
    
    if (stat.isDirectory) {
      // Read all Python files in directory
      for await (const entry of Deno.readDir(fullPath)) {
        if (entry.isFile && entry.name.endsWith('.py') && !entry.name.startsWith('__')) {
          filesToAnalyze.push(`${fullPath}/${entry.name}`);
        }
      }
    } else if (stat.isFile) {
      filesToAnalyze.push(fullPath);
    }

    if (filesToAnalyze.length === 0) {
      return {
        success: false,
        error: 'No Python files found to document'
      };
    }

    // Read all files
    const fileContents = await Promise.all(
      filesToAnalyze.map(async (path) => {
        const content = await Deno.readTextFile(path);
        const fileName = path.split('/').pop();
        return `### ${fileName}\n\`\`\`python\n${content.slice(0, 2000)}${content.length > 2000 ? '\n...(truncated)' : ''}\n\`\`\``;
      })
    );

    const prompt = `You are a technical documentation expert. Generate a comprehensive README.md for the following Python module/package.

The README should include:
1. **Overview**: Brief description of module purpose
2. **Key Components**: List of main functions/classes with brief descriptions
3. **Installation**: Any setup requirements
4. **Usage Examples**: 1-2 practical examples showing how to use the module
5. **API Reference**: Brief documentation of key public functions

Module files:
${fileContents.join('\n\n')}

Generate a clear, professional README.md in markdown format.`;

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${llmApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: 'You are a technical documentation expert. Generate clear, comprehensive README files.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.4,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return {
        success: false,
        error: `LLM API error: ${response.status} ${errorText}`
      };
    }

    const data = await response.json();
    const readmeContent = data.choices?.[0]?.message?.content;
    
    if (!readmeContent) {
      return {
        success: false,
        error: 'No README content generated'
      };
    }

    // Determine README path
    const readmePath = stat.isDirectory
      ? `${modulePath}/README.md`
      : `${modulePath.replace(/\.py$/, '')}_README.md`;

    return {
      success: true,
      readme_path: readmePath,
      content: readmeContent
    };

  } catch (error: any) {
    return {
      success: false,
      error: `Failed to generate README: ${error.message}`
    };
  }
}

/**
 * Create strategy template with required methods stubbed
 */
export async function createStrategy(
  strategyName: string,
  engineRoot: string
): Promise<StrategyTemplateResult> {
  try {
    // Validate strategy name
    if (!/^[a-z_][a-z0-9_]*$/.test(strategyName)) {
      return {
        success: false,
        error: 'Strategy name must be lowercase snake_case (e.g., my_strategy_v1)'
      };
    }

    const filePath = `strategies/${strategyName}.py`;
    const fullPath = `${engineRoot}/${filePath}`;

    // Check if file already exists
    try {
      await Deno.stat(fullPath);
      return {
        success: false,
        error: `Strategy file already exists: ${filePath}`
      };
    } catch {
      // File doesn't exist, which is what we want
    }

    const className = strategyName.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join('');

    const template = `"""
${className} Strategy

Description: [Add strategy description here]
Author: [Your name]
Created: ${new Date().toISOString().split('T')[0]}
"""

from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np


class ${className}:
    """
    ${className} - [Brief strategy description]
    
    This strategy implements [describe the core logic].
    
    Parameters
    ----------
    param1 : type
        Description of param1
    param2 : type
        Description of param2
    
    Attributes
    ----------
    positions : Dict
        Current open positions
    """
    
    def __init__(self, param1: float = 1.0, param2: int = 10):
        """
        Initialize ${className} strategy.
        
        Parameters
        ----------
        param1 : float, default=1.0
            Description of param1
        param2 : int, default=10
            Description of param2
        """
        self.param1 = param1
        self.param2 = param2
        self.positions = {}
    
    def generate_signals(
        self, 
        data: pd.DataFrame,
        timestamp: pd.Timestamp
    ) -> List[Dict]:
        """
        Generate trading signals based on market data.
        
        Parameters
        ----------
        data : pd.DataFrame
            Market data with OHLCV columns
        timestamp : pd.Timestamp
            Current timestamp
        
        Returns
        -------
        signals : List[Dict]
            List of signal dictionaries with keys:
            - 'action': 'buy' or 'sell'
            - 'symbol': str
            - 'size': float
            - 'reason': str
        """
        signals = []
        
        # TODO: Implement signal generation logic
        
        return signals
    
    def calculate_position_size(
        self,
        signal: Dict,
        portfolio_value: float,
        risk_params: Dict
    ) -> float:
        """
        Calculate position size based on signal and risk parameters.
        
        Parameters
        ----------
        signal : Dict
            Signal dictionary from generate_signals
        portfolio_value : float
            Current portfolio value
        risk_params : Dict
            Risk management parameters
        
        Returns
        -------
        size : float
            Position size to trade
        """
        # TODO: Implement position sizing logic
        return 1.0
    
    def should_exit(
        self,
        position: Dict,
        current_price: float,
        timestamp: pd.Timestamp
    ) -> Tuple[bool, Optional[str]]:
        """
        Determine if position should be exited.
        
        Parameters
        ----------
        position : Dict
            Current position details
        current_price : float
            Current market price
        timestamp : pd.Timestamp
            Current timestamp
        
        Returns
        -------
        should_exit : bool
            Whether to exit position
        reason : Optional[str]
            Exit reason if should_exit is True
        """
        # TODO: Implement exit logic
        return False, None


def create_strategy(**kwargs) -> ${className}:
    """
    Factory function to create ${className} instance.
    
    Parameters
    ----------
    **kwargs
        Strategy parameters passed to __init__
    
    Returns
    -------
    strategy : ${className}
        Initialized strategy instance
    """
    return ${className}(**kwargs)
`;

    return {
      success: true,
      file_path: filePath,
      content: template
    };

  } catch (error: any) {
    return {
      success: false,
      error: `Failed to create strategy template: ${error.message}`
    };
  }
}

/**
 * Create profile template JSON structure
 */
export async function createProfile(
  strategyKey: string,
  profileName: string,
  engineRoot: string
): Promise<ProfileTemplateResult> {
  try {
    // Validate profile name
    if (!/^[a-z_][a-z0-9_]*$/.test(profileName)) {
      return {
        success: false,
        error: 'Profile name must be lowercase snake_case (e.g., my_profile_v1)'
      };
    }

    const filePath = `profiles/${profileName}.json`;
    const fullPath = `${engineRoot}/${filePath}`;

    // Check if file already exists
    try {
      await Deno.stat(fullPath);
      return {
        success: false,
        error: `Profile file already exists: ${filePath}`
      };
    } catch {
      // File doesn't exist, which is what we want
    }

    const template = {
      "name": profileName,
      "description": "TODO: Add profile description",
      "strategy_key": strategyKey,
      "version": "1.0",
      "created": new Date().toISOString().split('T')[0],
      "parameters": {
        "param1": {
          "value": 1.0,
          "type": "float",
          "description": "TODO: Describe param1",
          "min": 0.0,
          "max": 10.0
        },
        "param2": {
          "value": 10,
          "type": "int",
          "description": "TODO: Describe param2",
          "min": 1,
          "max": 100
        }
      },
      "risk_management": {
        "max_position_size": 0.1,
        "max_portfolio_risk": 0.02,
        "stop_loss_pct": 0.05,
        "take_profit_pct": 0.15
      },
      "backtest_defaults": {
        "start_date": "2020-01-01",
        "end_date": "2024-12-31",
        "initial_capital": 100000,
        "commission": 0.001,
        "slippage": 0.0005
      },
      "notes": [
        "TODO: Add usage notes",
        "TODO: Document expected behavior",
        "TODO: List known limitations"
      ]
    };

    const content = JSON.stringify(template, null, 2);

    return {
      success: true,
      file_path: filePath,
      content
    };

  } catch (error: any) {
    return {
      success: false,
      error: `Failed to create profile template: ${error.message}`
    };
  }
}
